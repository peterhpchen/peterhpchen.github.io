# 正規表達式

## 宣告方式

* literal: 不能動態, 只能是固定的字串, 使用在知道內容不會有變化的情況, 效能較好.
* constructor: 可以是動態的, 使用在知道內容會有變化或是還不知道內容（例如從其他地方取得的字串）的情況.

### literal

宣告方式用斜線（/）夾住字串, 例如：`var re = /ab+c/;`.

### constructor

用`RegExp`建立實體, 例如：`var re = new RegExp('ab+c');`.

## 模式

正規表達式有兩種模式：simple跟special.

### simple

對於想要直接批配的結果, 我們直接使用單純的字串表示欲尋找的目標, 例如`/abc/`是找尋`abc`串連的字串.

### special

想要模糊搜尋時使用, 使用正規表達式定義的特殊字元做設定, 例如`/ab*c/`會對應到以`a`為開頭, 中間有零到多個`b`, 最後以`c`結尾的字串,  像是`ac`或是`abbbbbc`都會符合.

## 特殊字元

* `\`反斜線（backslash）：使接於其後的一般字元變為特殊字元, 特殊字元變為一般字元.
* `^`：以符合接於其**後**的字母開頭的輸入, 如果有設置多行的旗幟也會判斷換行字元**後**的字元是否符合.
* `$`：以符合接於其**前**的字母結尾的輸入, 如果有設置多行的旗幟也會判斷換行字元**前**的字元是否符合.
* `*`：符合此符號前面的字元零到多次.
* `+`：符合此符號前面的字元一到多次.
* `?`：符合此符號前面的字元零到一次.
* `.`：符合任何一個除了換行字元外的字元.
* `(x)`（capturing parentheses）：符合`x`且將其設為capturing parenthese(grouping).
* `(?:x)`（non-capturing parentheses）：符合`x`但不將其設為group, 用在要對整個字串做特殊比對時.
* `x(?=y)`（lookahead）：只有在`x`後面緊跟著`y`時才會抓出`x`.
* `x(?!y)`（negated lookahead）：只有在`x`後面沒有緊跟著`y`時才會抓出`x`.
* `x|y`：符合`x`或是`y`.
* `{n}`: 在此符號前的字元剛好重複n次才符合條件。
* `{n,}`: 此符號前的字元最少重複n次即符合條件。
* `{n,m}`: 此符號前的字元最少重複n次，最多重複m次才符合條件。
* `[xyz]`: 取得符合括號中的其中一個字元的字串。
* `[^xyz]`: 取得不符合括號中的任何字元的字串。
* `[\b]`: 取得退格字元。
* `\b`: 在字母字元前(後)沒有字母字元時符合此條件。

### `\`

反斜線的後面如果是一般字元的話代表此一般字元有特殊功能, 例如字元`b`原本是一般字元, 用來找尋符合小寫b的內容, 但如果是`\b`的話就代表字母邊界, 就是用來找尋所有用來切開字母的字元（例如空白, 符號...等）.

如果後面接的是特殊字元的話會將此字元視為一般字元, 例如`/a*/`會去找零到多個連續的`a`, 但如果使用`/a\*/`的話就會找尋符合`a*`的字串.

反斜線本身也是特殊字元, 如果要找尋反斜線請使用`\\`.

### `^`

在`^`後的字元為輸入或是斷行字元後的的開頭字元, 例如使用`/^A/`取找尋`an A`時會沒有符合的結果, 但`An E`就會符合`A`.

當`^`出現在字元集前會有不同的定義, 詳細請看字元集的說明.

### `$`

在`$`前面的字元為輸入或是斷行字元前的最後一個字元, 例如使用`/t$/`在`eater`中不會找到`t`, 但是在`eat`中會找到`t`.

### `*`

符合在`*`前面的字元零到多次, 其效果跟`{0,}`相同, 例如使用`/bo*/`, 在`A ghost booooed`中會找到`boooo`, 在`A bird warbled`中會找到`b`, 但`A goat grunted`找不到符合字串.

### `+`

符合在`+`前面的字元一到多次, 其效果跟`{1,}`一樣, 例如使用`/a+/`, 在`candy`中找的到`a`, 在`caaaaaaandy`中找的到所有`a`所組成的字串, 但是在`cndy`中找不到符合條件.

### `?`

符合在`?`前面的字元零到一次, 其效果跟`{0,1}`一樣, 例如使用`/e?le?/`, 在`angel`中找的到`el`, 在`angle`中找到`le`的字串, 在`oslo`中找到`l`字串.

如果在符號（`*`,`+`,`?`,`{}`）後加上`?`會將符合條件減至最少字元, 例如對`123abc`使用`/\d+/`會因為了符合最多的字串而取得`123`, 但是使用`/\d+?/`則只會符合最少字元的`1`.

在lookahead assertions中也會使用`x(?=y)`及`x(?!y)`來表示, 詳情請看下面章節.

### `.`

符合任何除了換行字元外的字元, 例如使用`/.n/`可以在`nay, an apple is on the tree`中符合`an`, `on`, 但是不能符合`nay`.

### `(x)`

取得符合x的字串且將結果放群組中, 例如使用`/(foo) (bar) \1 \2/`來取得`foo bar foo bar`會有兩個群組：群組1為`foo`, 群組2為`bar`, 而因為後面接續`\1 \2`所以完整的符合條件為`foo bar foo bar`, 後面的`\1`代表`foo`, `\2`代表`bar`（在`replace`中是用`$1`, `$2`來表示）.

### `(?:x)`

取得符合x的字串但不將結果放群組中, 用途在於想要對長度大於一的字串做正規表示式的運算時使用, 例如`/foo{1,2}/`後面的`{1,2}`的效果就只有在最後一個`o`才有效果, 可是`/(foo){1,2}/`雖然可以抓出重複`foo`一到兩次的結果, 但是它會多抓群組資料, 所以最佳解法就是`/(?:foo){1,2}/`.

### `x(?=y)`

只有在`x`後面緊跟著`y`時才會取得`x`, 例如`/Jack(?=Sprat)/`一定要`Jack`後面緊接著`Sprat`才會取得`Jack`, 而`Sprat`不會在結果裡面.

### `x(?!y)`

只有在`x`後面沒有緊跟著`y`時才會取得`x`, 例如`/\d+(?!\.)/`會對應到`3.141`中的`141`, 但不會對到`3`.

### `x|y`

符合x或y, 例如`/green|red/`在`green apple`中符合`green`, 在`red apple`中符合`red`.

在寫的時候需要注意順序, 越前面的條件被符合後就不會再去符合之後的條件, 例如對字串`b`做`a*|b`會因為符合了empty而傳回空字串, 如果使用`b|a*`就會先符合`b`而傳回`b`字母.

### `[xyz]`

取得符合中括號中其中一個字元的字元，跳脫字元及特殊字元在中括號內可以不用用反斜線(\\)來跳脫。

如果是有連續的字母或數字要設定可以用hypen(-)來設定，例如設定`[a-d]`的效果跟`[abcd]`是一樣的，而因為有特殊字元不用反斜線的特性所以`/[a-z.]+/`會跟`/[\w.]+/`一樣符合`test.i.ng`全部的字串。

### `[^xyz]`

取得不符合中括號中的任何字元，其特性跟`[xyz]`相同。

例如`[^abc]`跟`[^a-c]`相同，在`brisket`中因第一個`b`不符合條件所以會抓到`r`，而`chop`也是會抓到`h`。

### `[\b]`

符合退格字元的條件。

### `\b`

在字母字元前(後)沒有字母字元時符合此條件，截斷字母字元的字元不會被列入結果中，也可以將截斷的字元想成長度是0的字元。

下面有三個例子:

* `/\bm/`會符合`moon`中的`m`，因為`m`的前面不是字母字元。
* `/oo\b/`對於`moon`不會符合任何字串，因為`oo`後面接的是字母`n`。
* `/oon\b/`會符合`moon`中的`oon`。
* `/\w\b\w/`不會符合任何條件，因為不會有一個字母後面同時跟著非字母及字母的情況發生。