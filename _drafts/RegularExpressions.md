# 正規表達式

## 宣告方式

* literal: 不能動態, 只能是固定的字串, 使用在知道內容不會有變化的情況, 效能較好.
* constructor: 可以是動態的, 使用在知道內容會有變化或是還不知道內容（例如從其他地方取得的字串）的情況.

### literal

宣告方式用斜線（/）夾住字串, 例如：`var re = /ab+c/;`.

### constructor

用`RegExp`建立實體, 例如：`var re = new RegExp('ab+c');`.

## 模式

正規表達式有兩種模式：simple跟special.

### simple

對於想要直接批配的結果, 我們直接使用單純的字串表示欲尋找的目標, 例如`/abc/`是找尋`abc`串連的字串.

### special

想要模糊搜尋時使用, 使用正規表達式定義的特殊字元做設定, 例如`/ab*c/`會對應到以`a`為開頭, 中間有零到多個`b`, 最後以`c`結尾的字串,  像是`ac`或是`abbbbbc`都會符合.

## 特殊字元

* `\`反斜線（backslash）：使接於其後的一般字元變為特殊字元, 特殊字元變為一般字元.
* `^`：以符合接於其**後**的字母開頭的輸入, 如果有設置多行的旗幟也會判斷換行字元**後**的字元是否符合.
* `$`：以符合接於其**前**的字母結尾的輸入, 如果有設置多行的旗幟也會判斷換行字元**前**的字元是否符合.
* `*`：符合此符號前面的字元零到多次.
* `+`：符合此符號前面的字元一到多次.
* `?`：符合此符號前面的字元零到一次.
* `.`：符合任何一個除了換行字元外的字元.
* `(x)`（capturing parentheses）：符合`x`且將其設為capturing parenthese(grouping).
* `(?:x)`（non-capturing parentheses）：符合`x`但不將其設為group, 用在要對整個字串做特殊比對時.
* `x(?=y)`（lookahead）：只有在`x`後面緊跟著`y`時才會抓出`x`.
* `x(?!y)`（negated lookahead）：只有在`x`後面沒有緊跟著`y`時才會抓出`x`.
* `x|y`：符合`x`或是`y`.
* `{n}`: 在此符號前的字元剛好重複n次才符合條件。
* `{n,}`: 此符號前的字元最少重複n次即符合條件。
* `{n,m}`: 此符號前的字元最少重複n次，最多重複m次才符合條件。
* `[xyz]`: 取得符合括號中的其中一個字元的字串。
* `[^xyz]`: 取得不符合括號中的任何字元的字串。
* `[\b]`: 取得退格字元。
* `\b`: 在字母字元前(後)沒有字母字元時符合此條件，本身不算是結果的一部分。
* `\B`: 在字母字元前(後)有字母字元時符合條件，本身不算是結果的一部分。
* `\cX`: X為A-Z的字母，此為符合某個控制字元的條件。
* `\d`: 任何數字字元都符合條件。
* `\D`: 任何非數字字元都符合條件。
* `\f`: 符合form feed(U+000C)條件。
* `\n`: 符合line feed(U+000A)條件。
* `\r`: 符合carriage return(U+000D)條件。
* `\t`: 符合tab(U+0009)條件。
* `\v`: 符合vertical tab(U+000B)條件。
* `\s`: 符合空白字元的條件。
* `\S`: 符合所有非空白字元的條件。
* `\w`: 符合所有字母及數字字元的條件。
* `\W`: 符合所有非字母及數字字元的條件。
* `\n`: 符合第n個`()`括號中的子字串條件。
* `\0`: 符合NULL(U+0000)條件。
* `\xhh`: 符合以16進位表示的字元條件。
* `\uhhhh`: 符合以16進位表示的字元條件。
* `\u{hhhh}`: 符合以16進為表示的unicode，要`/u` flag有設置時才有用。

### `\`

反斜線的後面如果是一般字元的話代表此一般字元有特殊功能, 例如字元`b`原本是一般字元, 用來找尋符合小寫b的內容, 但如果是`\b`的話就代表字母邊界, 就是用來找尋所有用來切開字母的字元（例如空白, 符號...等）.

如果後面接的是特殊字元的話會將此字元視為一般字元, 例如`/a*/`會去找零到多個連續的`a`, 但如果使用`/a\*/`的話就會找尋符合`a*`的字串.

反斜線本身也是特殊字元, 如果要找尋反斜線請使用`\\`.

### `^`

在`^`後的字元為輸入或是斷行字元後的的開頭字元, 例如使用`/^A/`取找尋`an A`時會沒有符合的結果, 但`An E`就會符合`A`.

當`^`出現在字元集前會有不同的定義, 詳細請看字元集的說明.

### `$`

在`$`前面的字元為輸入或是斷行字元前的最後一個字元, 例如使用`/t$/`在`eater`中不會找到`t`, 但是在`eat`中會找到`t`.

### `*`

符合在`*`前面的字元零到多次, 其效果跟`{0,}`相同, 例如使用`/bo*/`, 在`A ghost booooed`中會找到`boooo`, 在`A bird warbled`中會找到`b`, 但`A goat grunted`找不到符合字串.

### `+`

符合在`+`前面的字元一到多次, 其效果跟`{1,}`一樣, 例如使用`/a+/`, 在`candy`中找的到`a`, 在`caaaaaaandy`中找的到所有`a`所組成的字串, 但是在`cndy`中找不到符合條件.

### `?`

符合在`?`前面的字元零到一次, 其效果跟`{0,1}`一樣, 例如使用`/e?le?/`, 在`angel`中找的到`el`, 在`angle`中找到`le`的字串, 在`oslo`中找到`l`字串.

如果在符號（`*`,`+`,`?`,`{}`）後加上`?`會將符合條件減至最少字元, 例如對`123abc`使用`/\d+/`會因為了符合最多的字串而取得`123`, 但是使用`/\d+?/`則只會符合最少字元的`1`.

在lookahead assertions中也會使用`x(?=y)`及`x(?!y)`來表示, 詳情請看下面章節.

### `.`

符合任何除了換行字元外的字元, 例如使用`/.n/`可以在`nay, an apple is on the tree`中符合`an`, `on`, 但是不能符合`nay`.

如果放在[]中的話會變成一般字元。

由於`.`不包含換行字元，如果要包含換行字元可以用`[^]`來比對。

### `(x)`

取得符合x的字串且將結果放群組中, 例如使用`/(foo) (bar) \1 \2/`來取得`foo bar foo bar`會有兩個群組：群組1為`foo`, 群組2為`bar`, 而因為後面接續`\1 \2`所以完整的符合條件為`foo bar foo bar`, 後面的`\1`代表`foo`, `\2`代表`bar`（在`replace`中是用`$1`, `$2`來表示），而`$&`代表完整的字串.

### `(?:x)`

取得符合x的字串但不將結果放群組中, 用途在於想要對長度大於一的字串做正規表示式的運算時使用, 例如`/foo{1,2}/`後面的`{1,2}`的效果就只有在最後一個`o`才有效果, 可是`/(foo){1,2}/`雖然可以抓出重複`foo`一到兩次的結果, 但是它會多抓群組資料, 所以最佳解法就是`/(?:foo){1,2}/`.

### `x(?=y)`

只有在`x`後面緊跟著`y`時才會取得`x`, 例如`/Jack(?=Sprat)/`一定要`Jack`後面緊接著`Sprat`才會取得`Jack`, 而`Sprat`不會在結果裡面.

### `x(?!y)`

只有在`x`後面沒有緊跟著`y`時才會取得`x`, 例如`/\d+(?!\.)/`會對應到`3.141`中的`141`, 但不會對到`3`.

### `x|y`

符合x或y, 例如`/green|red/`在`green apple`中符合`green`, 在`red apple`中符合`red`.

在寫的時候需要注意順序, 越前面的條件被符合後就不會再去符合之後的條件, 例如對字串`b`做`a*|b`會因為符合了empty而傳回空字串, 如果使用`b|a*`就會先符合`b`而傳回`b`字母.

### `[xyz]`

取得符合中括號中其中一個字元的字元，跳脫字元及特殊字元在中括號內可以不用用反斜線(\\)來跳脫。

如果是有連續的字母或數字要設定可以用hypen(-)來設定，例如設定`[a-d]`的效果跟`[abcd]`是一樣的，而因為有特殊字元不用反斜線的特性所以`/[a-z.]+/`會跟`/[\w.]+/`一樣符合`test.i.ng`全部的字串。

### `[^xyz]`

取得不符合中括號中的任何字元，其特性跟`[xyz]`相同。

例如`[^abc]`跟`[^a-c]`相同，在`brisket`中因第一個`b`不符合條件所以會抓到`r`，而`chop`也是會抓到`h`。

### `[\b]`

符合退格字元的條件。

### `\b`

在字母字元前(後)沒有字母字元時符合此條件，截斷字母字元的字元不會被列入結果中，也可以將截斷的字元想成長度是0的字元。

下面有三個例子:

* `/\bm/`會符合`moon`中的`m`，因為`m`的前面不是字母字元。
* `/oo\b/`對於`moon`不會符合任何字串，因為`oo`後面接的是字母`n`。
* `/oon\b/`會符合`moon`中的`oon`。
* `/\w\b\w/`不會符合任何條件，因為不會有一個字母後面同時跟著非字母及字母的情況發生。

字母字元的定義在[ECMAScript](http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.6)上有寫。

### `\B`

在字母字元前(後)若是字母字元的話則符合此條件，本身不會是結果的一部分，在它的左右兩邊同時要是字母字元或是非字母字元。

例如對`noonday`使用`/\B../`會對應到`oo`，而對`possibly yesterday`使用`/y\B./`會對應到`ye`，因為\B本身不算結果的一部分，所以不會對應到`y y`。

### `\cX`

`X`為A-Z中其中一個字元，代表各個不同的控制字元，`ASCII 1`對應到`\cA`，`ASCII 26`對應到`\cZ`。

例如我們要找LF(Newline)字元，可以用`\cJ`(`U+000A`)來取得。

### `\d`

符合任何數字字元的條件，跟`[0-9]`效果相同。

例如在`B2 is the suite number.`中用`/\d/`或`/[0-9]/`會找到`2`。

### `\D`

符合任何非數字字元的條件，跟`[^0-9]`效果相同。

例如在`B2 is the suite number.`中用`/\D/`或`/[^0-9]/`會找到`B`。

### `\f`, `\n`, `\r`, `\t`, `\v`

這個系列為符合各個控制字元，`\f`符合form feed(U+000C)條件，`\n`符合line feed(U+000A)條件， `\r`符合carriage return(U+000D)條件，`\t`符合tab(U+0009)條件，`\v`符合vertical tab(U+000B)條件，也可以是用`\cX`的方式取得，前面三個字元的差異請參考[這篇](https://stackoverflow.com/a/3098328)，vertical tab可以參考[這篇](https://stackoverflow.com/a/3380554)。

### `\s`

符合空白字元的條件，空白字元包括space, tab, form feed, line feed，它的效果會同於`[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。

例如對`foo bar.`使用`/\s\w*/`，`\s`會對應至空白字元，`\w*`會對應零到無限個字母字元，所以取得的結果會是`bar`。

### `\S`

符合所有非空白字元的條件，空白字元包括space, tab, form feed, line feed，它的效果會同於`[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。

例如對`foo bar.`使用`/\S*/`，`\S`會對應至非空白字元，所以取得的結果會是`foo`。

### `\w`

符合所有字母數字的字元條件，效果同於`[A-Za-z0-9_]`。

例如`/\w/`在`apple`中符合`a`，在`$5.28,`中符合`5`，在`3D`中符合`3`。

### `\W`

符合所有字母數字的字元條件，效果同於`[^A-Za-z0-9_]`。

例如`/\w/`在`50%.`中符合`%`。

### `\n`

n是一個正整數，為符合第n個()小括號中的字串條件。

例如用`/apple(,)\sorange\1/`查找`apple, orange, cherry, peach.`會符合`apple, orange,`。

### `\0`

符合NULL字元的條件，注意後面不能接數字，如果接的話會被當作跳脫字元，可以用`\x00`取代。

## 括號

在正規表達式使用括號可以使括號中的字串被記錄。

以`/Chapter (\d+)\.\d*/`為例，在()中的一到多個數字會被記錄起來，所以`Open Chapter 4.3, paragraph 6`會取得`Chapter 4.3`這個完整的符合字串及`4`這個括號中的子字串。

## flag

* m: 換行字元後視為新的行數，可以用^等邊界條件查找。

### m

例如`\nIs th\nis it?`如果用`/^is/`查找的話會因為`is`再換行字元後所以找不到，用`/^is/m`就可以找到目標。